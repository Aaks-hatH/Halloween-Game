<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>The Locked Dungeon</title>
<link href="https://fonts.googleapis.com/css2?family=Creepster&display=swap" rel="stylesheet">
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: linear-gradient(180deg,#0a0a0a 0%,#1a0a0a 60%,#0a0a0a 100%);
    color: #ff8c00;
    font-family: "Creepster", cursive, sans-serif;
    text-align: center;
    padding: 30px;
    min-height: 100vh;
    position: relative;
    overflow-x: hidden;
  }
  h1 { 
    font-size: clamp(2rem,5vw,3rem); 
    margin-bottom: 8px; 
    text-shadow:0 0 20px #ff4500;
    animation: flicker 4s infinite;
  }
  @keyframes flicker {
    0%, 100% { opacity: 1; text-shadow: 0 0 20px #ff4500; }
    50% { opacity: 0.8; text-shadow: 0 0 10px #ff4500; }
  }
  .subtitle { margin-bottom: 14px; opacity: .9; }
  
  /* Floating ghosts */
  .ghost {
    position: fixed;
    font-size: 3rem;
    opacity: 0.3;
    pointer-events: none;
    z-index: 1;
    animation: floatGhost 20s infinite linear;
  }
  @keyframes floatGhost {
    0% { transform: translateX(-100px) translateY(0) rotate(0deg); }
    100% { transform: translateX(calc(100vw + 100px)) translateY(-50px) rotate(360deg); }
  }
  
  /* Fog effect */
  .fog {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 200px;
    background: linear-gradient(to top, rgba(100,100,100,0.1), transparent);
    pointer-events: none;
    z-index: 1;
    animation: fogMove 30s infinite ease-in-out;
  }
  @keyframes fogMove {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.5; }
  }
  
  /* Timer */
  .timer-container {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(20,20,20,0.9);
    border: 2px solid #ff8c00;
    border-radius: 10px;
    padding: 10px 20px;
    z-index: 100;
    font-size: 1.5rem;
  }
  .timer { color: #ff8c00; }
  .timer.warning { color: #ff0000; animation: pulse 1s infinite; }
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }
  
  /* Difficulty selector */
  .difficulty-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
  }
  .difficulty-content {
    background: linear-gradient(135deg, rgba(20,20,20,0.95), rgba(30,15,10,0.95));
    border: 3px solid #ff8c00;
    border-radius: 20px;
    padding: 40px;
    max-width: 600px;
  }
  .difficulty-btn {
    display: block;
    width: 100%;
    margin: 15px 0;
    padding: 15px;
    font-size: 1.5rem;
    background: linear-gradient(135deg, #ff8c00, #ff6600);
    border: none;
    border-radius: 10px;
    color: #0a0a0a;
    cursor: pointer;
    font-family: "Creepster", cursive;
    transition: transform 0.2s;
  }
  .difficulty-btn:hover { transform: scale(1.05); }
  
  /* Admin panel */
  .admin-toggle {
    position: fixed;
    bottom: 20px;
    left: 20px;
    background: rgba(20,20,20,0.9);
    border: 2px solid #666;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 10002;
    font-size: 1.5rem;
    opacity: 0.5;
    transition: opacity 0.3s;
  }
  .admin-toggle:hover { opacity: 1; }
  
  /* Music controls */
  .music-toggle {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: rgba(20,20,20,0.9);
    border: 2px solid #ff8c00;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 10002;
    font-size: 1.5rem;
    transition: all 0.3s;
  }
  .music-toggle:hover {
    transform: scale(1.1);
    box-shadow: 0 0 20px rgba(255,140,0,0.5);
  }
  .music-toggle.playing {
    animation: musicPulse 2s infinite;
  }
  @keyframes musicPulse {
    0%, 100% { box-shadow: 0 0 10px rgba(255,140,0,0.3); }
    50% { box-shadow: 0 0 25px rgba(255,140,0,0.7); }
  }
  
  .admin-panel {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(20,20,20,0.98);
    border: 3px solid #ff8c00;
    border-radius: 20px;
    padding: 30px;
    z-index: 10003;
    max-width: 800px;
    max-height: 80vh;
    overflow-y: auto;
    display: none;
  }
  .admin-panel.active { display: block; }
  .admin-section {
    margin: 20px 0;
    padding: 15px;
    background: rgba(10,10,10,0.5);
    border-radius: 10px;
  }
  .stat-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 15px;
    margin-top: 15px;
  }
  .stat-card {
    background: rgba(255,140,0,0.1);
    border: 1px solid #ff8c00;
    border-radius: 8px;
    padding: 10px;
    font-size: 0.9rem;
  }
  .stat-value {
    font-size: 1.8rem;
    color: #ff8c00;
    margin: 5px 0;
  }
  
  .riddle-container { max-width: 900px; margin: 18px auto; display: grid; grid-template-columns: 1fr; gap: 18px; position: relative; z-index: 2; }
  .riddle-card {
    background: linear-gradient(135deg, rgba(20,20,20,.95), rgba(30,15,10,.95));
    border: 1px solid rgba(255,140,0,.2);
    padding: 18px;
    border-radius: 14px;
    transition: all 0.3s;
  }
  .riddle-card.solved {
    border-color: rgba(0,255,0,0.6);
    box-shadow: 0 0 20px rgba(0,255,0,0.3);
  }
  .riddle-text {
    background: rgba(10,10,10,.9);
    border: 1px solid rgba(255,140,0,.15);
    border-radius: 8px;
    padding: 20px;
    margin: 12px 0;
    color: #ffb366;
    font-family: "Creepster", cursive, sans-serif;
    font-size: 1.3rem;
    line-height: 1.8;
    white-space: pre-wrap;
    text-align: left;
  }
  .riddle-controls { display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap; margin-top: 15px; }
  input[type=text], input[type=password] {
    padding:10px 14px; 
    border-radius:10px; 
    border:2px solid rgba(255,140,0,.3);
    background: rgba(10,10,10,.85); 
    color: #ff8c00; 
    width: 220px; 
    font-family: "Creepster", cursive, sans-serif;
    text-align:center;
    font-size: 1.2rem;
  }
  button { 
    padding:10px 18px; 
    border-radius:10px; 
    border:none; 
    font-weight:bold; 
    cursor:pointer; 
    background: linear-gradient(135deg,#ff8c00,#ff6600); 
    color:#0a0a0a;
    transition: transform 0.1s;
    font-size: 1.2rem;
    font-family: "Creepster", cursive, sans-serif;
  }
  button:hover { transform: scale(1.05); }
  button:active { transform: scale(0.98); }
  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  button.danger {
    background: linear-gradient(135deg, #ff0000, #cc0000);
    color: white;
  }
  button.secondary {
    background: linear-gradient(135deg, #666, #444);
    color: white;
  }
  #progressFill { 
    height:30px; 
    width:0%; 
    display:flex; 
    align-items:center; 
    justify-content:center; 
    border-radius:8px; 
    background: linear-gradient(90deg,#ff8c00,#ff6600); 
    color:#0a0a0a; 
    font-weight:bold;
    transition: width 0.3s;
    font-family: "Creepster", cursive, sans-serif;
  }
  .progress-bar { 
    width:100%; 
    background: rgba(10,10,10,.8); 
    border-radius:8px; 
    border:1px solid rgba(255,140,0,.2); 
    padding:3px; 
    margin-bottom:12px; 
  }
  #hintBox { 
    display:none; 
    max-width:760px; 
    margin:12px auto; 
    padding:12px; 
    background: rgba(10,10,10,.95); 
    border-radius:8px; 
    border:1px solid rgba(255,140,0,.2); 
  }
  #result { margin-top:10px; min-height:26px; font-family: "Creepster", cursive, sans-serif; font-size: 1.2rem; }
  .feedback {
    min-height: 22px;
    margin-top: 10px;
    font-family: "Creepster", cursive, sans-serif;
    font-size: 1.1rem;
  }
  .lives-display {
    display: inline-block;
    margin-left: 15px;
    font-size: 1.5rem;
  }
  .credits {
    margin-top: 60px;
    padding: 30px 20px;
    max-width: 760px;
    margin-left: auto;
    margin-right: auto;
    background: linear-gradient(135deg, rgba(20,20,20,.8), rgba(30,15,10,.8));
    border: 1px solid rgba(255,140,0,.15);
    border-radius: 14px;
    position: relative;
    z-index: 2;
  }
  .credits h3 {
    color: #ff8c00;
    font-size: 1.8rem;
    margin-bottom: 20px;
    text-shadow: 0 0 10px #ff4500;
  }
  .credits-list {
    display: flex;
    flex-direction: column;
    gap: 15px;
    font-family: "Creepster", cursive, sans-serif;
  }
  .credit-item {
    color: #ffb366;
    font-size: 1.2rem;
    line-height: 1.5;
  }
  .credit-name {
    color: #ff8c00;
    font-weight: bold;
    font-size: 1.4rem;
  }
  .credit-role {
    color: #cc7700;
    font-style: italic;
  }
  .no-select {
    -webkit-user-select: none; 
    -moz-user-select:none; 
    -ms-user-select:none; 
    user-select:none;
  }
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  .share-btn {
    margin-top: 20px;
    background: linear-gradient(135deg, #00aa00, #008800);
  }
  
  @media (max-width:640px) {
    input[type=text], input[type=password] { width: 150px; font-size: 1rem; }
    button { font-size: 1rem; }
    .riddle-text { font-size: 1.1rem; }
    .timer-container { top: 10px; right: 10px; font-size: 1.2rem; }
  }
</style>
</head>
<body>

<!-- Floating ghosts -->
<div class="ghost" style="top: 10%; animation-delay: 0s;">üëª</div>
<div class="ghost" style="top: 30%; animation-delay: 5s;">üéÉ</div>
<div class="ghost" style="top: 60%; animation-delay: 10s;">üíÄ</div>
<div class="fog"></div>

<!-- Timer -->
<div class="timer-container" id="timerContainer" style="display: none;">
  <div class="timer" id="timer">‚è±Ô∏è 0:00</div>
</div>

<!-- Admin toggle -->
<div class="admin-toggle" id="adminToggle" title="Admin Panel">‚öôÔ∏è</div>

<h1>üíÄ The Locked Dungeon üíÄ</h1>
<p class="subtitle">Solve the five riddles. The first letter of each answer spells the final code.</p>

<div class="progress-card riddle-card" style="position: relative; z-index: 2;">
  <div style="max-width:760px;margin:0 auto;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;flex-wrap:wrap;">
      <strong>Progress</strong>
      <div>
        <small id="progressText">0 / 5 solved</small>
        <span class="lives-display" id="livesDisplay"></span>
      </div>
    </div>
    <div class="progress-bar"><div id="progressFill" style="width:0%">0/5</div></div>
  </div>
</div>

<div class="riddle-container" id="riddleContainer"></div>

<div class="riddle-card" style="max-width:760px;margin:16px auto; position: relative; z-index: 2;">
  <h3 style="margin-bottom:12px;">Enter the Final Code</h3>
  <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap;">
    <input id="codeInput" type="text" maxlength="5" placeholder="5-letter code (A..Z)">
    <button id="unlockBtn">Unlock</button>
  </div>
  <p id="result"></p>
</div>

<div style="margin:12px auto 40px;max-width:760px; position: relative; z-index: 2;">
  <button id="hintBtn">üí° Need a Hint?</button>
  <div id="hintBox"></div>
</div>

<div class="credits">
  <h3>üéÉ Credits üéÉ</h3>
  <div class="credits-list">
    <div class="credit-item">
      <span class="credit-name">Aakshat Hariharan</span><br>
      <span class="credit-role">Developer & Creator</span>
    </div>
    <div class="credit-item">
      <span class="credit-name">Kory Alerte</span><br>
      <span class="credit-role">Co-Creator & Author</span>
    </div>
  </div>
</div>

<!-- Admin Panel -->
<div class="admin-panel" id="adminPanel">
  <h2 style="margin-bottom: 20px;">‚öôÔ∏è Admin Panel</h2>
  
  <div class="admin-section">
    <h3 style="margin-bottom: 10px;">üîê Authentication</h3>
    <div id="adminLogin">
      <input type="password" id="adminPassword" placeholder="Enter admin password" style="width: 250px;">
      <button onclick="adminLogin()">Login</button>
    </div>
    <div id="adminContent" style="display: none;">
      <p style="color: #00ff00;">‚úì Authenticated</p>
    </div>
  </div>
  
  <div class="admin-section" id="adminStats" style="display: none;">
    <h3 style="margin-bottom: 10px;">üìä Analytics</h3>
    <div class="stat-grid">
      <div class="stat-card">
        <div>Total Attempts</div>
        <div class="stat-value" id="statAttempts">0</div>
      </div>
      <div class="stat-card">
        <div>Completions</div>
        <div class="stat-value" id="statCompletions">0</div>
      </div>
      <div class="stat-card">
        <div>Locked Users</div>
        <div class="stat-value" id="statLocked">0</div>
      </div>
      <div class="stat-card">
        <div>Avg Time</div>
        <div class="stat-value" id="statAvgTime">0:00</div>
      </div>
      <div class="stat-card">
        <div>Best Time</div>
        <div class="stat-value" id="statBestTime">--</div>
      </div>
      <div class="stat-card">
        <div>Hints Used</div>
        <div class="stat-value" id="statHints">0</div>
      </div>
    </div>
  </div>
  
  <div class="admin-section" id="adminControls" style="display: none;">
    <h3 style="margin-bottom: 10px;">üéÆ Controls</h3>
    <button onclick="resetProgress()" class="secondary">Reset Progress</button>
    <button onclick="unlockUser()" class="secondary">Unlock This User</button>
    <button onclick="clearAllData()" class="danger">Clear All Analytics</button>
    <button onclick="exportData()" class="secondary">Export Data</button>
  </div>
  
  <div style="margin-top: 20px;">
    <button onclick="closeAdmin()" class="secondary">Close</button>
  </div>
</div>

<script>
(function() {
  'use strict';
  
  // Encrypted credentials (Base64 encoded)
  const ENCRYPTED_ADMIN_USER = atob('QWFrcy1oYXRI');
  const ENCRYPTED_ADMIN_PASS = atob('QWFrc2hhdGFkbWlu');
  let isAdminAuthenticated = false;
  
  // Decrypt function for answers
  function decrypt(encoded) {
    return atob(encoded);
  }
  
  // Riddles data (answers encrypted)
  const riddlesByDifficulty = {
    easy: [
      {id: 1, title: "Riddle 1", text: "I have no body, but I can appear,\nI whisper in your ear, but vanish near.\n\nYou'll feel my chill though I am air,\nWhat am I, haunting everywhere?", answer: decrypt('Rw==')},
      {id: 2, title: "Riddle 2", text: "I am full of ghosts, cobwebs, and fright,\nPeople visit me on Halloween night.\nDark and spooky is my style,\nWhat am I?", answer: decrypt('SA==')},
      {id: 3, title: "Riddle 3", text: "Round and hollow, dark my core,\nI open wide but have no door.\nWithout me, faces cannot see\nWhat letter am I meant to be?\n(Hint: The letter is a Shape)", answer: decrypt('Tw==')},
      {id: 4, title: "Riddle 4", text: "Neither living nor quite dead,\nI rise again when moonlight's shed.\nI shamble slow, with vacant hue\nGuess my name.", answer: decrypt('VQ==')},
      {id: 5, title: "Riddle 5", text: "I live inside a haunted flame,\nWithout me, dark would rule the game.\nI flicker soft, I guard your soul\nWhat am I, with shining role?", answer: decrypt('TA==')}
    ],
    medium: [
      {id: 1, title: "Riddle 1", text: "I have no body, but I can appear,\nI whisper in your ear, but vanish near.\n\nYou'll feel my chill though I am air,\nWhat am I, haunting everywhere?", answer: decrypt('Rw==')},
      {id: 2, title: "Riddle 2", text: "I am full of ghosts, cobwebs, and fright,\nPeople visit me on Halloween night.\nDark and spooky is my style,\nWhat am I?", answer: decrypt('SA==')},
      {id: 3, title: "Riddle 3", text: "Round and hollow, dark my core,\nI open wide but have no door.\nWithout me, faces cannot see\nWhat letter am I meant to be?", answer: decrypt('Tw==')},
      {id: 4, title: "Riddle 4", text: "Neither living nor quite dead,\nI rise again when moonlight's shed.\nI shamble slow, with vacant hue\nGuess my name.", answer: decrypt('VQ==')},
      {id: 5, title: "Riddle 5", text: "I live inside a haunted flame,\nWithout me, dark would rule the game.\nI flicker soft, I guard your soul\nWhat am I, with shining role?", answer: decrypt('TA==')}
    ],
    hard: [
      {id: 1, title: "Riddle 1", text: "I have no body, but I can appear,\nI whisper in your ear, but vanish near.\n\nYou'll feel my chill though I am air,\nWhat am I, haunting everywhere?", answer: decrypt('Rw==')},
      {id: 2, title: "Riddle 2", text: "I am full of ghosts, cobwebs, and fright,\nPeople visit me on Halloween night.\nDark and spooky is my style,\nWhat am I?", answer: decrypt('SA==')},
      {id: 3, title: "Riddle 3", text: "Round and hollow, dark my core,\nI open wide but have no door.\nWithout me, faces cannot see\nWhat letter am I meant to be?", answer: decrypt('Tw==')},
      {id: 4, title: "Riddle 4", text: "Neither living nor quite dead,\nI rise again when moonlight's shed.\nI shamble slow, with vacant hue\nGuess my name.", answer: decrypt('VQ==')},
      {id: 5, title: "Riddle 5", text: "I live inside a haunted flame,\nWithout me, dark would rule the game.\nI flicker soft, I guard your soul\nWhat am I, with shining role?", answer: decrypt('TA==')}
    ]
  };
  
  const hints = {
    "1": "Think of a chilling presence that has no physical body.",
    "2": "A place people visit on Halloween where scary things are displayed, two words.",
    "3": "A round letter that is also a shape.",
    "4": "A word for the category a walking dead creature is classified as.",
    "5": "A source of flickering illumination that keeps the dark away."
  };
  
  let riddles = [];
  let difficulty = null;
  let maxLives = 0;
  let lives = 0;
  let timeLimit = 0;
  let startTime = null;
  let timerInterval = null;
  let hintsUsed = 0;
  let totalHints = 0;
  let hintsRemaining = 0;
  
  const solved = {1:false, 2:false, 3:false, 4:false, 5:false};
  let tabSwitchCount = 0;
  let firstWarningShown = false;
  let isLocked = false;

  // Sanitize input to prevent injection attacks
  function sanitizeInput(input) {
    if (typeof input !== 'string') return '';
    return input
      .replace(/[<>"'`;&|*$(){}[\]]/g, '')
      .trim()
      .slice(0, 100);
  }

  function safeSetItem(key, value) {
    try {
      const sanitizedKey = sanitizeInput(key);
      const sanitizedValue = typeof value === 'string' ? value : JSON.stringify(value);
      localStorage.setItem(sanitizedKey, sanitizedValue);
      return true;
    } catch (e) {
      console.error('Storage error:', e);
      return false;
    }
  }

  function safeGetItem(key) {
    try {
      const sanitizedKey = sanitizeInput(key);
      return localStorage.getItem(sanitizedKey);
    } catch (e) {
      console.error('Storage error:', e);
      return null;
    }
  }

  // Analytics
  function trackEvent(event, data = {}) {
    try {
      const sanitizedEvent = sanitizeInput(event);
      const analytics = JSON.parse(safeGetItem('dungeon_analytics') || '{}');
      if (!analytics[sanitizedEvent]) analytics[sanitizedEvent] = [];
      analytics[sanitizedEvent].push({...data, timestamp: Date.now()});
      safeSetItem('dungeon_analytics', JSON.stringify(analytics));
    } catch (e) {
      console.error('Analytics error:', e);
    }
  }

  function getAnalytics() {
    try {
      const analytics = JSON.parse(safeGetItem('dungeon_analytics') || '{}');
      const attempts = (analytics.attempt || []).length;
      const completions = (analytics.complete || []).length;
      const locked = (analytics.locked || []).length;
      const hints = (analytics.hint || []).length;
      
      const completeTimes = (analytics.complete || []).map(c => c.time).filter(t => t);
      const avgTime = completeTimes.length ? completeTimes.reduce((a,b) => a+b, 0) / completeTimes.length : 0;
      const bestTime = completeTimes.length ? Math.min(...completeTimes) : 0;
      
      return {attempts, completions, locked, hints, avgTime, bestTime};
    } catch (e) {
      return {attempts: 0, completions: 0, locked: 0, hints: 0, avgTime: 0, bestTime: 0};
    }
  }

  function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  function updateTimer() {
    if (!startTime) return;
    const elapsed = Math.floor((Date.now() - startTime) / 1000);
    const remaining = timeLimit - elapsed;
    
    if (remaining <= 0) {
      endGame(false, 'Time\'s up! The dungeon remains locked forever.');
      return;
    }
    
    document.getElementById('timer').textContent = `‚è±Ô∏è ${formatTime(remaining)}`;
    if (remaining <= 60) {
      document.getElementById('timer').classList.add('warning');
    }
  }

  function startTimer() {
    if (timeLimit > 0) {
      document.getElementById('timerContainer').style.display = 'block';
      startTime = Date.now();
      timerInterval = setInterval(updateTimer, 1000);
      updateTimer();
    }
  }

  function stopTimer() {
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
  }

  function getElapsedTime() {
    if (!startTime) return 0;
    return Math.floor((Date.now() - startTime) / 1000);
  }

  // Difficulty selection
  function showDifficultyScreen() {
    const overlay = document.createElement('div');
    overlay.className = 'difficulty-screen';
    overlay.innerHTML = `
      <div class="difficulty-content">
        <h2 style="margin-bottom: 30px; font-size: 2.5rem;">Choose Your Fate</h2>
        <button class="difficulty-btn" onclick="selectDifficulty('easy')">
          üü¢ Easy Mode<br>
          <span style="font-size: 1rem;">Unlimited Lives ‚Ä¢ No Time Limit ‚Ä¢ 2 Hints Total</span>
        </button>
        <button class="difficulty-btn" onclick="selectDifficulty('medium')">
          üü° Medium Mode<br>
          <span style="font-size: 1rem;">5 Lives ‚Ä¢ 15 Minutes ‚Ä¢ 1 Hint Total</span>
        </button>
        <button class="difficulty-btn" onclick="selectDifficulty('hard')">
          üî¥ Hard Mode<br>
          <span style="font-size: 1rem;">3 Lives ‚Ä¢ 10 Minutes ‚Ä¢ No Hints</span>
        </button>
      </div>
    `;
    document.body.appendChild(overlay);
  }

  window.selectDifficulty = function(diff) {
    difficulty = sanitizeInput(diff);
    if (!['easy', 'medium', 'hard'].includes(difficulty)) {
      alert('Invalid difficulty selected!');
      return;
    }
    
    riddles = riddlesByDifficulty[difficulty];
    
    switch(difficulty) {
      case 'easy':
        maxLives = 999;
        timeLimit = 0;
        totalHints = 2;
        hintsRemaining = 2;
        break;
      case 'medium':
        maxLives = 5;
        timeLimit = 15 * 60;
        totalHints = 1;
        hintsRemaining = 1;
        break;
      case 'hard':
        maxLives = 3;
        timeLimit = 10 * 60;
        totalHints = 0;
        hintsRemaining = 0;
        break;
    }
    
    lives = maxLives;
    document.querySelector('.difficulty-screen').remove();
    trackEvent('attempt', {difficulty: difficulty});
    saveProgress();
    init();
  };

  // Save/Load progress
  function saveProgress() {
    try {
      const progress = {
        difficulty,
        solved,
        lives,
        startTime,
        timeLimit,
        hintsUsed,
        hintsRemaining,
        tabSwitchCount
      };
      safeSetItem('dungeon_progress', JSON.stringify(progress));
    } catch (e) {
      console.error('Save error:', e);
    }
  }

  function loadProgress() {
    try {
      const saved = safeGetItem('dungeon_progress');
      if (!saved) return false;
      
      const progress = JSON.parse(saved);
      if (!progress.difficulty) return false;
      
      difficulty = sanitizeInput(progress.difficulty);
      if (!['easy', 'medium', 'hard'].includes(difficulty)) return false;
      
      riddles = riddlesByDifficulty[difficulty];
      Object.assign(solved, progress.solved);
      lives = parseInt(progress.lives) || maxLives;
      hintsUsed = parseInt(progress.hintsUsed) || 0;
      hintsRemaining = parseInt(progress.hintsRemaining) || 0;
      tabSwitchCount = parseInt(progress.tabSwitchCount) || 0;
      startTime = progress.startTime;
      timeLimit = parseInt(progress.timeLimit) || 0;
      
      switch(difficulty) {
        case 'easy': 
          maxLives = 999;
          totalHints = 2;
          break;
        case 'medium': 
          maxLives = 5;
          totalHints = 1;
          break;
        case 'hard': 
          maxLives = 3;
          totalHints = 0;
          break;
      }
      
      return true;
    } catch (e) {
      console.error('Load error:', e);
      return false;
    }
  }

  function checkInitialLock() {
    try {
      const locked = safeGetItem('dungeon_locked');
      if (locked === 'true') {
        const count = parseInt(safeGetItem('tab_switch_count') || '5');
        showPermanentLock(count);
        return true;
      }
    } catch (e) {
      console.error('Storage error:', e);
    }
    return false;
  }

  function stripZeroWidth(str) {
    return str.replace(/[\u200B\u200C\u200D\uFEFF\u2060]/g, '');
  }

  function updateLivesDisplay() {
    if (maxLives === 999) {
      document.getElementById('livesDisplay').innerHTML = '';
    } else {
      const hearts = '‚ù§Ô∏è'.repeat(lives) + 'üíî'.repeat(maxLives - lives);
      document.getElementById('livesDisplay').innerHTML = hearts;
    }
  }

  function createRiddleCard(r) {
    const card = document.createElement('div');
    card.className = 'riddle-card';
    card.id = 'card-' + r.id;

    const h = document.createElement('h3');
    h.textContent = r.title;
    h.style.marginBottom = '12px';
    card.appendChild(h);

    const riddleText = document.createElement('div');
    riddleText.className = 'riddle-text no-select';
    riddleText.textContent = r.text;
    card.appendChild(riddleText);

    const controls = document.createElement('div');
    controls.className = 'riddle-controls';
    
    const input = document.createElement('input');
    input.type = 'text';
    input.id = 'answer' + r.id;
    input.placeholder = 'Your answer';
    input.autocomplete = 'off';
    input.spellcheck = false;

    input.addEventListener('paste', (ev) => {
      ev.preventDefault();
      alert('Pasting is disabled. Please type your answer.');
    });
    input.addEventListener('copy', (ev) => ev.preventDefault());
    input.addEventListener('cut', (ev) => ev.preventDefault());

    const submit = document.createElement('button');
    submit.textContent = 'Submit';
    submit.onclick = () => checkRiddle(r.id);

    const feedback = document.createElement('div');
    feedback.className = 'feedback';
    feedback.id = 'feedback' + r.id;

    controls.appendChild(input);
    controls.appendChild(submit);
    card.appendChild(controls);
    card.appendChild(feedback);

    return card;
  }

  function renderRiddles() {
    const container = document.getElementById('riddleContainer');
    riddles.forEach(r => {
      container.appendChild(createRiddleCard(r));
    });
  }

  function updateProgressDisplay() {
    const solvedCount = Object.values(solved).filter(Boolean).length;
    const pct = (solvedCount/5) * 100;
    document.getElementById('progressFill').style.width = pct + '%';
    document.getElementById('progressFill').textContent = `${solvedCount}/5`;
    document.getElementById('progressText').textContent = `${solvedCount} / 5 solved`;
  }

  function checkRiddle(id) {
    if (isLocked) {
      alert('Page is locked due to excessive tab switching.');
      return;
    }
    
    const inp = document.getElementById('answer' + id);
    const fb = document.getElementById('feedback' + id);
    if (!inp) return;
    
    let val = sanitizeInput(inp.value || '').trim();
    val = stripZeroWidth(val);
    
    if (!val) {
      fb.style.color = '#ff4444';
      fb.textContent = 'Please type an answer.';
      return;
    }
    
    const first = val[0].toUpperCase();
    const riddle = riddles.find(r => r.id === id);
    if (!riddle) return;
    
    const expected = riddle.answer.toUpperCase();
    
    if (first === expected) {
      solved[id] = true;
      fb.style.color = '#00cc66';
      fb.textContent = '‚úì Correct ‚Äî nice work.';
      inp.disabled = true;
      const card = document.getElementById('card-' + id);
      if (card) card.classList.add('solved');
      updateProgressDisplay();
      saveProgress();
    } else {
      lives--;
      updateLivesDisplay();
      fb.style.color = '#ff4444';
      fb.textContent = '‚úó Incorrect ‚Äî try again.';
      
      if (lives <= 0) {
        endGame(false, 'You have run out of lives! The dungeon claims your soul...');
      }
      
      setTimeout(() => { fb.textContent = ''; }, 3000);
      saveProgress();
    }
  }

  function getFinalCode() {
    return riddles.map(r => r.answer[0].toUpperCase()).join('');
  }

  function endGame(success, message) {
    stopTimer();
    isLocked = true;
    
    document.querySelectorAll('input, button').forEach(el => {
      if (!el.closest('.admin-panel') && el.id !== 'adminToggle') {
        el.disabled = true;
      }
    });
    
    const res = document.getElementById('result');
    res.style.color = success ? '#00cc66' : '#ff4444';
    res.textContent = message;
    
    if (success) {
      const time = getElapsedTime();
      trackEvent('complete', {difficulty, time, hintsUsed});
      safeSetItem('dungeon_progress', '');
    }
  }

  document.getElementById('unlockBtn').addEventListener('click', () => {
    if (isLocked) {
      alert('Page is locked due to excessive tab switching.');
      return;
    }
    const codeInput = document.getElementById('codeInput');
    const res = document.getElementById('result');
    let entered = sanitizeInput(codeInput.value || '').trim().toUpperCase();
    entered = stripZeroWidth(entered);
    
    if (!entered) {
      res.style.color = '#ff8c00';
      res.textContent = 'Enter the 5-letter code to escape!';
      return;
    }
    if (entered.length !== 5) {
      res.style.color = '#ff4444';
      res.textContent = 'Code must be 5 letters.';
      return;
    }
    
    const target = getFinalCode();
    if (entered === target) {
      endGame(true, 'üéâ You have escaped the dungeon! The spirits bow to your wisdom. üéâ');
      showShareButton();
    } else {
      lives--;
      updateLivesDisplay();
      res.style.color = '#ff4444';
      res.textContent = '‚ùå Wrong code... The dungeon remains locked.';
      
      if (lives <= 0) {
        endGame(false, 'You have run out of lives! The dungeon claims your soul...');
      }
      saveProgress();
    }
  });

  function showShareButton() {
    const time = getElapsedTime();
    const res = document.getElementById('result');
    const shareBtn = document.createElement('button');
    shareBtn.className = 'share-btn';
    shareBtn.textContent = 'üì§ Share Your Victory';
    shareBtn.onclick = () => {
      const text = `I escaped the Locked Dungeon in ${formatTime(time)} on ${difficulty} mode! üíÄüéÉ Can you beat my time?`;
      if (navigator.share) {
        navigator.share({title: 'Locked Dungeon Victory', text});
      } else {
        navigator.clipboard.writeText(text);
        alert('Victory message copied to clipboard!');
      }
    };
    res.appendChild(document.createElement('br'));
    res.appendChild(shareBtn);
  }

  document.getElementById('codeInput').addEventListener('paste', (ev) => {
    ev.preventDefault();
    alert('Pasting is disabled. Please type your answer.');
  });

  document.getElementById('hintBtn').addEventListener('click', () => {
    const hb = document.getElementById('hintBox');
    
    if (hintsRemaining <= 0) {
      hb.style.display = 'block';
      hb.innerHTML = `<p class="no-select" style="font-family: Creepster, cursive, sans-serif; font-size: 1.2rem;">‚õî No hints remaining! (${hintsUsed}/${totalHints} used)</p>`;
      return;
    }
    
    const rn = prompt('Which riddle do you want a hint for? (1-5)');
    
    if (!rn) {
      hb.style.display = 'none'; 
      hb.innerHTML = '';
      return;
    }
    
    const n = parseInt(sanitizeInput(rn));
    
    if (n < 1 || n > 5 || !hints[n]) {
      hb.style.display = 'block';
      hb.innerHTML = `<p class="no-select" style="font-family: Creepster, cursive, sans-serif; font-size: 1.2rem;">That riddle doesn't exist ‚Äî try a number from 1 to 5.</p>`;
      return;
    }
    
    hb.style.display = 'block';
    hb.innerHTML = `<p class="no-select" style="font-family: Creepster, cursive, sans-serif; font-size: 1.2rem;">üí° Hint for Riddle ${n}: ${hints[n]}<br><br>Hints remaining: ${hintsRemaining - 1}/${totalHints}</p>`;
    hintsRemaining--;
    hintsUsed++;
    trackEvent('hint', {riddle: n, difficulty});
    saveProgress();
  });

  // Admin functions
  document.getElementById('adminToggle').addEventListener('click', () => {
    document.getElementById('adminPanel').classList.toggle('active');
  });

  window.adminLogin = function() {
    const pass = sanitizeInput(document.getElementById('adminPassword').value);
    if (pass === ENCRYPTED_ADMIN_PASS) {
      isAdminAuthenticated = true;
      document.getElementById('adminLogin').style.display = 'none';
      document.getElementById('adminContent').style.display = 'block';
      document.getElementById('adminStats').style.display = 'block';
      document.getElementById('adminControls').style.display = 'block';
      updateAdminStats();
    } else {
      alert('Incorrect password!');
    }
  };

  window.closeAdmin = function() {
    document.getElementById('adminPanel').classList.remove('active');
  };

  function updateAdminStats() {
    const stats = getAnalytics();
    document.getElementById('statAttempts').textContent = stats.attempts;
    document.getElementById('statCompletions').textContent = stats.completions;
    document.getElementById('statLocked').textContent = stats.locked;
    document.getElementById('statAvgTime').textContent = formatTime(Math.floor(stats.avgTime));
    document.getElementById('statBestTime').textContent = stats.bestTime ? formatTime(stats.bestTime) : '--';
    document.getElementById('statHints').textContent = stats.hints;
  }

  window.resetProgress = function() {
    if (!isAdminAuthenticated) {
      alert('Admin authentication required!');
      return;
    }
    if (confirm('Reset current progress? This will restart the game.')) {
      safeSetItem('dungeon_progress', '');
      location.reload();
    }
  };

  window.unlockUser = function() {
    if (!isAdminAuthenticated) {
      alert('Admin authentication required!');
      return;
    }
    if (confirm('Unlock this user and allow them to play again?')) {
      safeSetItem('dungeon_locked', '');
      safeSetItem('tab_switch_count', '');
      location.reload();
    }
  };

  window.clearAllData = function() {
    if (!isAdminAuthenticated) {
      alert('Admin authentication required!');
      return;
    }
    if (confirm('Clear all analytics data? This cannot be undone!')) {
      safeSetItem('dungeon_analytics', '');
      updateAdminStats();
      alert('Analytics cleared!');
    }
  };

  window.exportData = function() {
    if (!isAdminAuthenticated) {
      alert('Admin authentication required!');
      return;
    }
    const analytics = safeGetItem('dungeon_analytics') || '{}';
    const blob = new Blob([analytics], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'dungeon-analytics-' + Date.now() + '.json';
    a.click();
  };

  // Anti-cheat
  document.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    return false;
  });

  document.addEventListener('keydown', (e) => {
    if (
      (e.ctrlKey && (e.key === 'c' || e.key === 'C')) ||
      (e.ctrlKey && (e.key === 'x' || e.key === 'X')) ||
      (e.ctrlKey && (e.key === 'u' || e.key === 'U')) ||
      (e.ctrlKey && e.shiftKey && (e.key === 'i' || e.key === 'I')) ||
      (e.ctrlKey && e.shiftKey && (e.key === 'j' || e.key === 'J')) ||
      (e.ctrlKey && e.shiftKey && (e.key === 'c' || e.key === 'C')) ||
      e.key === 'F12'
    ) {
      e.preventDefault();
      return false;
    }
  });

  document.body.classList.add('no-select');
  const inputs = document.querySelectorAll('input[type="text"]');
  inputs.forEach(input => {
    input.style.userSelect = 'text';
    input.style.webkitUserSelect = 'text';
  });

  // Tab switch detection
  document.addEventListener('visibilitychange', () => {
    if (isLocked) return;
    
    if (document.hidden) {
      tabSwitchCount++;
      saveProgress();
      
      if (tabSwitchCount >= 5) {
        lockPage();
      }
    } else {
      if (tabSwitchCount === 1 && !firstWarningShown) {
        showWarning(
          '‚ö†Ô∏è WARNING ‚ö†Ô∏è',
          `Tab switching detected!<br><br>Using external help (like ChatGPT) defeats the purpose of this puzzle.<br><br>Try to solve it yourself!`,
          `Switches detected: ${tabSwitchCount}<br><strong style="color: #ff4444;">After 5 switches, the page will be PERMANENTLY LOCKED!</strong>`
        );
        firstWarningShown = true;
      } else if (tabSwitchCount >= 3 && tabSwitchCount < 5) {
        showWarning(
          'üö® FINAL WARNING üö®',
          `You have switched tabs ${tabSwitchCount} times!<br><br>One more switch and the page will be PERMANENTLY LOCKED!<br><br><strong style="color: #ff0000;">Even refreshing won't help!</strong>`,
          `Switches remaining: ${5 - tabSwitchCount}`
        );
      }
    }
  });

  function showWarning(title, message, footer) {
    const overlay = document.createElement('div');
    overlay.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95); display: flex;
      align-items: center; justify-content: center; z-index: 10000;
      animation: fadeIn 0.3s ease;
    `;

    const warningBox = document.createElement('div');
    warningBox.style.cssText = `
      background: linear-gradient(135deg, rgba(139, 0, 0, 0.95), rgba(70, 0, 0, 0.95));
      border: 3px solid #ff4444; border-radius: 20px; padding: 40px;
      max-width: 500px; text-align: center;
      box-shadow: 0 0 50px rgba(255, 68, 68, 0.5);
    `;

    warningBox.innerHTML = `
      <h2 style="color: #ff4444; font-size: 2rem; margin-bottom: 20px; font-family: Creepster, cursive;">${title}</h2>
      <p style="color: #ffaa66; font-size: 1.3rem; margin-bottom: 20px; line-height: 1.8; font-family: Creepster, cursive;">
        ${message}
      </p>
      <p style="color: #ff8c00; font-size: 1.1rem; margin-bottom: 25px; font-family: Creepster, cursive;">
        ${footer}
      </p>
      <button id="acknowledgeBtn" style="
        padding: 15px 30px; font-size: 1.3rem; border-radius: 12px;
        border: none; background: linear-gradient(135deg, #ff8c00, #ff6600);
        color: #0a0a0a; font-weight: bold; cursor: pointer;
        font-family: Creepster, cursive;
      ">I Understand</button>
    `;

    overlay.appendChild(warningBox);
    document.body.appendChild(overlay);
    
    const btn = warningBox.querySelector('#acknowledgeBtn');
    btn.onclick = () => overlay.remove();
  }

  function lockPage() {
    isLocked = true;
    stopTimer();
    
    try {
      safeSetItem('dungeon_locked', 'true');
      safeSetItem('tab_switch_count', tabSwitchCount.toString());
      trackEvent('locked', {tabSwitches: tabSwitchCount, difficulty});
    } catch (e) {
      console.error('Failed to save lock:', e);
    }
    
    showPermanentLock(tabSwitchCount);
  }

  function showPermanentLock(count) {
    isLocked = true;
    
    const overlay = document.createElement('div');
    overlay.id = 'lockOverlay';
    overlay.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(139, 0, 0, 0.98); display: flex;
      align-items: center; justify-content: center; z-index: 10000;
      animation: fadeIn 0.5s ease;
    `;

    const lockBox = document.createElement('div');
    lockBox.style.cssText = `
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(70, 0, 0, 0.95));
      border: 4px solid #ff0000; border-radius: 20px; padding: 50px;
      max-width: 600px; text-align: center;
      box-shadow: 0 0 80px rgba(255, 0, 0, 0.8);
    `;

    lockBox.innerHTML = `
      <h1 style="color: #ff0000; font-size: 3rem; margin-bottom: 30px; font-family: Creepster, cursive;">üîí PERMANENTLY LOCKED üîí</h1>
      <p style="color: #ffaa66; font-size: 1.5rem; margin-bottom: 20px; line-height: 1.8; font-family: Creepster, cursive;">
        You have been caught switching tabs too many times!<br><br>
        The dungeon is now PERMANENTLY LOCKED.<br><br>
        Refreshing the page will not help.
      </p>
      <p style="color: #ff8c00; font-size: 1.3rem; font-family: Creepster, cursive; font-style: italic; margin-top: 30px;">
        Tab switches detected: ${count}
      </p>
    `;

    overlay.appendChild(lockBox);
    document.body.appendChild(overlay);
    
    // Keep admin toggle and panel accessible
    const adminToggle = document.getElementById('adminToggle');
    const adminPanel = document.getElementById('adminPanel');
    if (adminToggle) adminToggle.style.zIndex = '10002';
    if (adminPanel) adminPanel.style.zIndex = '10003';
    
    document.querySelectorAll('input, button').forEach(el => {
      if (!el.closest('.admin-panel') && el.id !== 'adminToggle') {
        el.disabled = true;
      }
    });
  }

  // Initialize
  function init() {
    const wasLocked = checkInitialLock();
    if (wasLocked) return;
    
    const hasProgress = loadProgress();
    
    if (!hasProgress && !difficulty) {
      showDifficultyScreen();
    } else if (difficulty) {
      renderRiddles();
      updateProgressDisplay();
      updateLivesDisplay();
      startTimer();
    }
  }

  init();

})();
 // ===== BACKEND CONNECTION =====
const SERVER_URL = "https://halloween-game-1.onrender.com";
let ws = null;
let sessionId = null;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;

function connectWebSocket() {
  const protocol = SERVER_URL.startsWith("https") ? "wss:" : "ws:";
  const wsUrl = SERVER_URL.replace(/^https?/, protocol);
  ws = new WebSocket(wsUrl);

  ws.onopen = () => {
    console.log("‚úÖ Connected to backend");
    reconnectAttempts = 0;
  };

  ws.onmessage = (e) => {
    const msg = JSON.parse(e.data);
    if (msg.type === "session_id") sessionId = msg.sessionId;
    if (msg.type === "lock_status" && msg.locked) {
      alert("üîí Your session was locked by admin!");
      document.querySelectorAll("input,button").forEach((b) => (b.disabled = true));
    }
    if (msg.type === "lock_status" && !msg.locked) {
      alert("üîì Unlocked by admin!");
      document.querySelectorAll("input,button").forEach((b) => (b.disabled = false));
    }
    if (msg.type === "reset") {
      alert("üîÑ Your progress has been reset!");
      localStorage.clear();
      location.reload();
    }
  };

  ws.onclose = () => {
    if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
      setTimeout(connectWebSocket, 1000 * ++reconnectAttempts);
    }
  };
}

document.addEventListener("DOMContentLoaded", connectWebSocket);

// Save progress and events to backend
function saveProgress(progress) {
  fetch(`${SERVER_URL}/api/session`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ sessionId, progress }),
  });
}

function trackEvent(event, details = {}) {
  fetch(`${SERVER_URL}/api/event`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ sessionId, event, details }),
  });
}

</script>
</body>
</html>
